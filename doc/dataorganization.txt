Data Organization and Entry Points
==================================

Our input sources include packet sockets, the operating system's netlink
infrastructure, filesystem events, and UI events.

Actions invoked by the UI and service interrogations performed automatically by
omphalos will most often operate naturally at layer 3 or above: a port scan
cannot be run against a MAC, nor can a DNS request be issued to one. Inputs
from the packet socket, however, are most naturally keyed off of layer 2
(especially since a given layer 3 address can show up on multiple layer 2
networks, which MAC addresses' global uniqueness property makes less common).
The netlink layer, meanwhile, refers almost exclusively to logical interfaces,
and various device properties are associated with physical interfaces.

It must be remembered that misconfigured and adversarial peers can violate the
expected properties at any layer save the physical. Other cases to consider,
with definite effects on network modeling, include:

 - multipath routing
 - line bonding
 - proxy ARP
 - disconnected IP networks (local overload of global IP space)
 - multiple cards on the same medium
 - multihoming
 - fail-over/load-balancing
 - unconfigured local networking
 - movement among physical networks without local networking changes
 - same mac address on different networks
 - overeager dhcp
 - etc. ...

Upon receipt of a packet, we know ab initio:

 - the interface on which it was received, *if* we use sockaddr_ll (sll_ifindex
	field), or we're binding a SOCK_RAW socket to each interface. We're
	doing the latter.
 - whether it was ours or not, *if* we use sockaddr_ll (sll_pkttype field).
	we're using SOCK_RAW with our AF_PACKETs, though, since SOCK_DGRAM
	doesn't provide us with the destination address.
 - source hardware address (sll_addr, or look at the physical header) and
	address length *if* we use sockaddr_ll (sll_halen field) or we're
	binding a SOCK_RAW socket to each interface, after discovering its
	hardware address length. Note that this assumed all hardware on a given
	medium have the same hardware length.
 - destination hardware address *iff* we're using SOCK_RAW.
 - physical layer protocol (sll_protocol field, or look at the physical header).
 - length of the frame

Of these, the addresses and protocol are set by the sender. Everything else can
be trusted as objectively "accurate". There's a fine line between an adversarial
deception and reality, however. If an adversary spoofs a MAC address and IP
address, and provides service on it, treating this as another host is not a
problem. If an adversary successfully takes over a router's IP via ARP hijack,
but faithfully forwards all traffic, not knowing the router's true MAC is not a
problem. Real issues we must concern ourselves with include:

 - traffic randomized across the address space in an attempt to starve us of
	resources. a meaningful attack must uniquely exploit our operation, or
	else the attacker is simply DoS'ing the network.
  - we defend against this with algorithms and bounded resource allocation
 - traffic designed to mislead our network analysis. this would include
	advertisement of false routes, hijacking of addresses without
	subsequent forwarding, simulation of dns service from whence it is not
	offered, etc.
  - we defend against this by supporting and testing contradictory information
 - traffic designed to be amplified by our automated actions.
  - we defend against this by ensuring only a finite number (preferably 1) of
	packets (including potential replies) are issued. this is most easily
	done by never automatically transmitting to non-unicast addresses,
	and never automatically triggering stateful reconnaissance. this is by
	no means a complete solution, but it seems the best we can do.

It would be useful if logical interfaces could determine that they share a
medium, but this seems impossible in the general case. Seeing the same hardware
address on multiple interfaces could be the result of generated addresses,
misconfigurations, adversaries, or use of well-known addresses (primarily
multicast and broadcast). Seeing the other card's generated packets could be
the result of misconfiguration, adversarial routing/bridging, adversarial
packet generation (a node with connections to both distinct media could
replicate packets from one to another), etc.

Indexing
========

We need be able to index by logical interface, hardware address, and network
address. Network addresses need be indexed by range, with the ranges organized
by routes. Interfaces contain many hardware addresses; these hardware addresses
may be shared between interfaces, and up to two entities ('ourselves' and
'others') may shared a hardware address on any given interface (this indicates
a misconfiguration, our seizure of another address, or seizure by some other
entity of our own. We cannot generally differentiate between two hosts sharing
a MAC address). Hardware addresses may contain many local network addresses and
many routes. Network addresses are associated with some number of hardware
addresses, potentially on different interfaces. Routes are associated with a
single network address and a single interface. Note that the network address is
not necessary to actually route through the hardware address; routing only
requires the router's network address if the corresponding hardware address is
missing from the neighbor cache.

Packet Receipt
==============

What information can we glean from a packet on the wire? Ignore trust for the
moment. Assume an IPv4 or IPv6 header. This header will have a source and
destination address. We usually ought be able to route to these addresses on
the receiving interface -- if we can't, it's probably due to one of:

 - any number of misconfigurations/failures in any number of places
 - spoofing of source address
 - one-way route
 - our lack of configuration (a special case of misconfiguration)

None of these are particularly interesting, or even necessarily
distinguishable, save the last; if we're lacking configuration, it ought
usually be possible to infer it  -- so far as is necessary to communicate with
entities we've seen -- via active analysis. ARP can be used to determine
whether a hardware address claims a given IP address; a router will not (Proxy
ARP, as mentioned before, can complicate this). An ARP probe requires an IP
address, which we might not have (or might not be in the same network as the
address seen due to misconfiguration etc), but we can spoof someone else's and
gather information that way (indeed, it might be possible to use the target's
own IP address (which we must know) as our source, so long as we supply our
hardware address as a source, and receive the reply). We run the risk in this
case, however, of upsetting other nodes' own ARP caches, and thus ought be
prepared to forward traffic in the case of an unintentional MitM.
