#ifndef OMPHALOS_INTERFACE
#define OMPHALOS_INTERFACE

#ifdef __cplusplus
extern "C" {
#endif

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdint.h>
#include <pthread.h>
#include <arpa/inet.h>
#include <sys/socket.h>
#include <linux/if.h>
#include <omphalos/128.h>
#include <omphalos/arp.h>
#include <linux/ethtool.h>
#include <linux/if_packet.h>
#include <omphalos/timing.h>
#include <omphalos/hwaddrs.h>

struct l2host;
struct l3host;
struct in_addr;
struct in6_addr;
struct psocket_marsh;
struct omphalos_iface;
struct omphalos_packet;

// bitmasks for the routes' 'addrs' field
#define ROUTE_HAS_SRC	0x1
#define ROUTE_HAS_VIA	0x2

typedef struct ip4route {
	uint32_t dst,via,src;
	unsigned addrs;
	unsigned maskbits;		// 0..31
	int iif;			// input iface, -1 if unspecified
	struct ip4route *next;
} ip4route;

typedef struct ip6route {
	uint128_t dst,via,src;
	unsigned addrs;
	unsigned maskbits;		// 0..127
	int iif;			// input iface, -1 if unspecified
	struct ip6route *next;
} ip6route;

typedef struct wless_info {
	unsigned bitrate;
	unsigned mode;
	uintmax_t freq;			// 0..999: channel, 1000+: frequency
} wless_info;
#define MAX_WIRELESS_CHANNEL		999

typedef struct topdev_info {
	char *devname;			// as in output from lspci or lsusb
} topdev_info;

typedef void (*analyzefxn)(const struct omphalos_iface *,
		struct omphalos_packet *,const void *,size_t);

#define IFACE_TIMESTAT_USECS 40000
#define IFACE_TIMESTAT_SLOTS 125

typedef struct interface {
	// Packet analysis entry point
	analyzefxn analyzer;

	// Lock (packet thread vs netlink layer vs UI)
	pthread_mutex_t lock;

	// Lifetime stats
	uintmax_t frames;		// Frames received on the interface
	uintmax_t malformed;		// Packet had malformed L2 -- L4 headers
	uintmax_t truncated;		// Packet didn't fit in ringbuffer frame
	uintmax_t truncated_recovered;	// We were able to recvfrom() the packet
	uintmax_t noprotocol;		// Packets without protocol handler
	uintmax_t bytes;		// Total bytes sniffed
	uintmax_t drops;		// PACKET_STATISTICS @ TP_STATUS_LOSING
	uintmax_t txframes;		// Frames generated by omphalos
	uintmax_t txbytes;		// Total bytes generated by omphalos
	uintmax_t txaborts;		// TX frames handed out but aborted

	// Finite time domain stats
	timestat fps,bps;		// frames and bits per second

	struct psocket_marsh *pmarsh;	// State for packet socket thread

	// For recvfrom()ing truncated packets (see PACKET_COPY_THRESH sockopt)
	void *truncbuf;
	size_t truncbuflen;

	unsigned arptype;	// from rtnetlink(7) ifi_type
	unsigned flags;		// from rtnetlink(7) ifi_flags
	int mtu;		// to match netdevice(7)'s ifr_mtu...
	char *name;
	void *addr;		// multiple hwaddrs are multiple ifaces...
	void *bcast;		// l2 broadcast address (not valid unless
				//	(iface->flags & IFF_BROADCAST) is set)
	size_t addrlen;		// length of l2 addresses (addr, bcast, ...)
	int rfd;		// RX packet socket
	void *rxm;		// RX packet ring buffer
	size_t rs;		// RX packet ring size in bytes
	struct tpacket_req rtpr;// RX packet ring descriptor
	int fd;			// TX packet socket
	void *txm;		// TX packet ring buffer
	size_t ts;		// TX packet ring size in bytes
	struct tpacket_req ttpr;// TX packet ring descriptor
	unsigned txidx;		// Index of next frame for TX
	void *curtxm;		// Location of next frame for TX
	struct ethtool_drvinfo drv;	// ethtool driver info
	unsigned offload;	// offloading settings
	unsigned offloadmask;	// which offloading settings are valid
	const char *busname;	// "pci", "usb" etc (from sysfs/bus/)
	enum {
		SETTINGS_INVALID,
		SETTINGS_VALID_ETHTOOL,
		SETTINGS_VALID_WEXT,
	} settings_valid;	// set if the settings field can be trusted
	union {
		struct ethtool_cmd ethtool;	// ethtool settings info
		struct wless_info wext;		// wireless extensions info
	} settings;
	topdev_info topinfo;
	// Other interfaces might also offer routes to these same
	// destinations -- they must not be considered unique!
	struct ip4route *ip4r;	// list of IPv4 routes
	struct ip6route *ip6r;	// list of IPv6 routes

	struct l2host *l2hosts;
	struct l3host *l3hosts;

	void *opaque;		// opaque callback state
} interface;

int init_interfaces(void);
interface *iface_by_idx(int);
int print_iface_stats(FILE *,const interface *,interface *,const char *);

static inline char *
hwaddrstr(const interface *i){
	char *r;

	if( (r = malloc(HWADDRSTRLEN(i->addrlen))) ){
		l2ntop(i->addr,i->addrlen,r);
	}
	return r;
}

void free_iface(const struct omphalos_iface *,interface *);
void cleanup_interfaces(const struct omphalos_iface *);
int print_all_iface_stats(FILE *,interface *);
int add_route4(interface *,const struct in_addr *,const struct in_addr *,
				const struct in_addr *,unsigned,int);
int add_route6(interface *,const struct in6_addr *,const struct in6_addr *,
				const struct in6_addr *,unsigned,int);
int del_route4(interface *,const struct in_addr *,unsigned);
int del_route6(interface *,const struct in6_addr *,unsigned);

const ip4route *get_route4(const interface *,const uint32_t *);
const ip6route *get_route6(const interface *,const void *);

#include <assert.h>
static inline const void *
get_route(const struct omphalos_iface *octx,interface *i,const void *hwaddr,
			int fam,const void *addr,void *r){
	int ret = 0;

	switch(fam){
		case AF_INET:{
			const ip4route *i4r = get_route4(i,addr);

			if(i4r){
				// A routed result requires a directed ARP
				// probe to verify the local network address.
				if(i4r->addrs & ROUTE_HAS_VIA){
					if( (i4r = get_route4(i,&i4r->via)) ){
						if(i4r->addrs & ROUTE_HAS_SRC){
							send_arp_probe(octx,i,hwaddr,
									&i4r->via,
									sizeof(uint32_t),
									&i4r->src);
						}
					}
				}else{
					ret = 1;
					memcpy(r,addr,sizeof(uint32_t));
				}
			}
			break;
		}case AF_INET6:{
			const ip6route *i6r = get_route6(i,addr);

			if(i6r){ // FIXME handle routed addresses!
				if(!(i6r->addrs & ROUTE_HAS_VIA)){
					ret = 1;
					memcpy(r,addr,sizeof(uint128_t));
				}
			}
			break;
		}default:
			break;
	}
	return (ret != 1) ? NULL : r;
}

// predicates. racey against netlink messages.
int is_local4(const interface *,uint32_t);
int is_local6(const interface *,const struct in6_addr *);

const char *lookup_arptype(unsigned,analyzefxn *);

int enable_promiscuity(const struct omphalos_iface *,const interface *);
int disable_promiscuity(const struct omphalos_iface *,const interface *);
int up_interface(const struct omphalos_iface *,const interface *);
int down_interface(const struct omphalos_iface *,const interface *);

static inline int
interface_sniffing_p(const interface *i){
	return (i->rfd >= 0);
}

static inline int
interface_up_p(const interface *i){
	return (i->flags & IFF_UP);
}

static inline int
interface_carrier_p(const interface *i){
	return (i->flags & IFF_LOWER_UP);
}

static inline int
interface_promisc_p(const interface *i){
	return (i->flags & IFF_PROMISC);
}

#ifdef __cplusplus
}
#endif

#endif
